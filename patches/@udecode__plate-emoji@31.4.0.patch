diff --git a/dist/index.mjs b/dist/index.mjs
index 3db72c864241a438a9ed3ea2860c311edcc2c410..c6a5d082493c39e2adcdd5cb3024dd1bfaa94b38 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -4,15 +4,21 @@ var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
 var __getOwnPropSymbols = Object.getOwnPropertySymbols;
 var __hasOwnProp = Object.prototype.hasOwnProperty;
 var __propIsEnum = Object.prototype.propertyIsEnumerable;
-var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
+var __defNormalProp = (obj, key, value) =>
+  key in obj
+    ? __defProp(obj, key, {
+        enumerable: true,
+        configurable: true,
+        writable: true,
+        value,
+      })
+    : (obj[key] = value);
 var __spreadValues = (a, b) => {
   for (var prop in b || (b = {}))
-    if (__hasOwnProp.call(b, prop))
-      __defNormalProp(a, prop, b[prop]);
+    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
   if (__getOwnPropSymbols)
     for (var prop of __getOwnPropSymbols(b)) {
-      if (__propIsEnum.call(b, prop))
-        __defNormalProp(a, prop, b[prop]);
+      if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
     }
   return a;
 };
@@ -41,7 +47,7 @@ var EmojiCategory = {
   Objects: "objects",
   People: "people",
   Places: "places",
-  Symbols: "symbols"
+  Symbols: "symbols",
 };
 
 // src/constants.ts
@@ -50,7 +56,7 @@ var EMOJI_TRIGGER = ":";
 var EMOJI_MAX_SEARCH_RESULT = 60;
 var emojiTriggeringControllerOptions = {
   trigger: EMOJI_TRIGGER,
-  limitTriggeringChars: 2
+  limitTriggeringChars: 2,
 };
 var defaultCategories = [
   EmojiCategory.People,
@@ -60,22 +66,22 @@ var defaultCategories = [
   EmojiCategory.Places,
   EmojiCategory.Objects,
   EmojiCategory.Symbols,
-  EmojiCategory.Flags
+  EmojiCategory.Flags,
 ];
 var EmojiSettings = {
   buttonSize: {
-    value: 36
+    value: 36,
   },
   perLine: {
-    value: 8
+    value: 8,
   },
   showFrequent: {
     value: true,
-    limit: 16
+    limit: 16,
   },
   categories: {
-    value: void 0
-  }
+    value: void 0,
+  },
 };
 var DEFAULT_FREQUENTLY_USED_EMOJI = {
   "+1": 1,
@@ -90,7 +96,7 @@ var DEFAULT_FREQUENTLY_USED_EMOJI = {
   rocket: 1,
   see_no_evil: 1,
   hugging_face: 1,
-  heart: 1
+  heart: 1,
 };
 var NUM_OF_CATEGORIES = Object.values(EmojiCategory).length;
 var i18n = {
@@ -110,17 +116,17 @@ var i18n = {
     objects: "Objects",
     people: "Smileys & People",
     places: "Travel & Places",
-    symbols: "Symbols"
+    symbols: "Symbols",
   },
   skins: {
     choose: "Choose default skin tone",
-    "1": "Default",
-    "2": "Light",
-    "3": "Medium-Light",
-    "4": "Medium",
-    "5": "Medium-Dark",
-    "6": "Dark"
-  }
+    1: "Default",
+    2: "Light",
+    3: "Medium-Light",
+    4: "Medium",
+    5: "Medium-Dark",
+    6: "Dark",
+  },
 };
 
 // src/createEmojiPlugin.ts
@@ -248,7 +254,7 @@ var AGridSection = class {
     const end = start + this.perLine;
     this.rows.push({
       elements: elements.slice(start, end),
-      id: this._indexRowStart + lastPosition
+      id: this._indexRowStart + lastPosition,
     });
   }
   get rowsNum() {
@@ -293,7 +299,7 @@ var EmojiFloatingGridBuilder = class {
         id,
         new EmojiGridSectionWithRoot(id, this.settings.perLine.value),
         {
-          [id]: this.localStorage.getList()
+          [id]: this.localStorage.getList(),
         }
       );
     }
@@ -312,10 +318,10 @@ var EmojiFloatingGridBuilder = class {
 };
 
 // src/utils/EmojiLibrary/EmojiFloatingLibrary.ts
-import emojiMartData2 from "@emoji-mart/data";
+import emojiMartData2 from "@emoji-mart/data" assert { type: "json" };
 
 // src/utils/EmojiLibrary/EmojiInlineLibrary.ts
-import emojiMartData from "@emoji-mart/data";
+import emojiMartData from "@emoji-mart/data" assert { type: "json" };
 var EmojiInlineLibrary = class {
   constructor(library = emojiMartData) {
     this._hash = {};
@@ -358,7 +364,8 @@ var EmojiFloatingLibrary = class _EmojiFloatingLibrary extends EmojiInlineLibrar
     this.library = library;
     this.categories = defaultCategories;
     this.emojis = {};
-    this.categories = (_a = settings.categories.value) != null ? _a : this.categories;
+    this.categories =
+      (_a = settings.categories.value) != null ? _a : this.categories;
     this.initEmojis(library.categories);
     this.grid = new EmojiFloatingGridBuilder(
       this.localStorage,
@@ -409,7 +416,7 @@ var initialState = {
   searchResult: [],
   focusedCategory: void 0,
   visibleCategories: /* @__PURE__ */ new Map(),
-  frequentEmoji: void 0
+  frequentEmoji: void 0,
 };
 var EmojiPickerState = () => {
   const [cache, dispatch] = React2.useReducer((state, action) => {
@@ -420,37 +427,46 @@ var EmojiPickerState = () => {
           searchValue: "",
           isSearching: false,
           hasFound: false,
-          focusedCategory: EmojiCategory.Frequent
+          focusedCategory: EmojiCategory.Frequent,
         });
       }
       case "UPDATE_SEARCH_RESULT": {
-        return __spreadProps(__spreadValues(__spreadValues({}, state), payload), {
-          isSearching: true,
-          focusedCategory: void 0
-        });
+        return __spreadProps(
+          __spreadValues(__spreadValues({}, state), payload),
+          {
+            isSearching: true,
+            focusedCategory: void 0,
+          }
+        );
       }
       case "SET_FOCUSED_CATEGORY": {
-        return __spreadProps(__spreadValues(__spreadValues({}, state), payload), {
-          searchValue: "",
-          isSearching: false,
-          hasFound: false
-        });
+        return __spreadProps(
+          __spreadValues(__spreadValues({}, state), payload),
+          {
+            searchValue: "",
+            isSearching: false,
+            hasFound: false,
+          }
+        );
       }
       case "SET_OPEN": {
         return __spreadProps(__spreadValues({}, state), {
-          isOpen: true
+          isOpen: true,
         });
       }
       case "SET_CLOSE": {
         return __spreadProps(__spreadValues({}, state), {
           emoji: void 0,
-          isOpen: false
+          isOpen: false,
         });
       }
       case "UPDATE_FREQUENT_EMOJIS": {
-        return __spreadProps(__spreadValues(__spreadValues({}, state), payload), {
-          emoji: void 0
-        });
+        return __spreadProps(
+          __spreadValues(__spreadValues({}, state), payload),
+          {
+            emoji: void 0,
+          }
+        );
       }
       case "SET_SEARCH":
       case "SET_EMOJI":
@@ -474,20 +490,20 @@ import {
   focusEditor,
   getPlugin,
   insertText,
-  withoutNormalizing
+  withoutNormalizing,
 } from "@udecode/plate-common";
-var getEmojiOnInsert = ({
-  key = KEY_EMOJI
-} = {}) => (editor, item) => {
-  const {
-    options: { createEmoji }
-  } = getPlugin(editor, key);
-  withoutNormalizing(editor, () => {
-    focusEditor(editor);
-    const value = createEmoji(item);
-    insertText(editor, value);
-  });
-};
+var getEmojiOnInsert =
+  ({ key = KEY_EMOJI } = {}) =>
+  (editor, item) => {
+    const {
+      options: { createEmoji },
+    } = getPlugin(editor, key);
+    withoutNormalizing(editor, () => {
+      focusEditor(editor);
+      const value = createEmoji(item);
+      insertText(editor, value);
+    });
+  };
 
 // src/utils/EmojiObserver.ts
 var setVisibleSections = (entries, visibleSections) => {
@@ -506,41 +522,37 @@ var getSectionInFocus = (visibleSections) => {
 var observeCategories = ({
   ancestorRef,
   emojiLibrary,
-  setFocusedAndVisibleSections
+  setFocusedAndVisibleSections,
 }) => {
   const observerOptions = {
     root: ancestorRef.current,
-    threshold: 0
+    threshold: 0,
   };
   const visibleSections = /* @__PURE__ */ new Map();
   const observer = new IntersectionObserver((entries) => {
     setVisibleSections(entries, visibleSections);
     const focusedSectionId = getSectionInFocus(visibleSections);
-    focusedSectionId && setFocusedAndVisibleSections(visibleSections, focusedSectionId);
+    focusedSectionId &&
+      setFocusedAndVisibleSections(visibleSections, focusedSectionId);
   }, observerOptions);
   for (const section of emojiLibrary.getGrid().sections()) {
-    if (section.root.current)
-      observer.observe(section.root.current);
+    if (section.root.current) observer.observe(section.root.current);
   }
   return observer;
 };
 
 // src/utils/EmojiPicker/useEmojiPicker.ts
-var useEmojiPicker = ({
-  emojiLibrary,
-  indexSearch,
-  closeOnSelect
-}) => {
+var useEmojiPicker = ({ emojiLibrary, indexSearch, closeOnSelect }) => {
   const editor = useEditorRef();
   const [state, dispatch] = EmojiPickerState();
   const refs = React3.useRef({
     contentRoot: React3.createRef(),
-    content: React3.createRef()
+    content: React3.createRef(),
   });
   const setIsOpen = React3.useCallback(
     (isOpen) => {
       dispatch({
-        type: isOpen ? "SET_OPEN" : "SET_CLOSE"
+        type: isOpen ? "SET_OPEN" : "SET_CLOSE",
       });
     },
     [dispatch]
@@ -551,8 +563,8 @@ var useEmojiPicker = ({
         type: "SET_FOCUSED_AND_VISIBLE_CATEGORIES",
         payload: {
           focusedCategory: categoryId,
-          visibleCategories: visibleSections
-        }
+          visibleCategories: visibleSections,
+        },
       });
     },
     [dispatch]
@@ -570,8 +582,8 @@ var useEmojiPicker = ({
         payload: {
           searchValue: value,
           hasFound,
-          searchResult: indexSearch.get()
-        }
+          searchResult: indexSearch.get(),
+        },
       });
     },
     [dispatch, indexSearch]
@@ -598,8 +610,8 @@ var useEmojiPicker = ({
         type: "UPDATE_FREQUENT_EMOJIS",
         payload: {
           frequentEmoji: emojiId,
-          isOpen: closeOnSelect ? false : state.isOpen
-        }
+          isOpen: closeOnSelect ? false : state.isOpen,
+        },
       });
     },
     [closeOnSelect, dispatch, emojiLibrary, state.isOpen]
@@ -614,8 +626,8 @@ var useEmojiPicker = ({
           id: emoji.id,
           emoji: emoji.skins[0].native,
           name: emoji.name,
-          text: emoji.name
-        }
+          text: emoji.name,
+        },
       });
       updateFrequentEmojis(emoji.id);
     },
@@ -625,19 +637,43 @@ var useEmojiPicker = ({
     (categoryId) => {
       dispatch({
         type: "SET_FOCUSED_CATEGORY",
-        payload: { focusedCategory: categoryId }
+        payload: { focusedCategory: categoryId },
       });
       const getSectionPositionToScrollIntoView = () => {
         var _a, _b, _c, _d, _e, _f;
         const trashHold = 1;
         const section = emojiLibrary.getGrid().section(categoryId);
-        const contentRootScrollTop = (_b = (_a = refs.current.contentRoot.current) == null ? void 0 : _a.scrollTop) != null ? _b : 0;
-        const contentRootTopPosition = (_d = (_c = refs.current.contentRoot.current) == null ? void 0 : _c.getBoundingClientRect().top) != null ? _d : 0;
-        const sectionTopPosition = (_f = (_e = section == null ? void 0 : section.root.current) == null ? void 0 : _e.getBoundingClientRect().top) != null ? _f : 0;
-        return trashHold + contentRootScrollTop + sectionTopPosition - contentRootTopPosition;
+        const contentRootScrollTop =
+          (_b =
+            (_a = refs.current.contentRoot.current) == null
+              ? void 0
+              : _a.scrollTop) != null
+            ? _b
+            : 0;
+        const contentRootTopPosition =
+          (_d =
+            (_c = refs.current.contentRoot.current) == null
+              ? void 0
+              : _c.getBoundingClientRect().top) != null
+            ? _d
+            : 0;
+        const sectionTopPosition =
+          (_f =
+            (_e = section == null ? void 0 : section.root.current) == null
+              ? void 0
+              : _e.getBoundingClientRect().top) != null
+            ? _f
+            : 0;
+        return (
+          trashHold +
+          contentRootScrollTop +
+          sectionTopPosition -
+          contentRootTopPosition
+        );
       };
       if (refs.current.contentRoot.current) {
-        refs.current.contentRoot.current.scrollTop = getSectionPositionToScrollIntoView();
+        refs.current.contentRoot.current.scrollTop =
+          getSectionPositionToScrollIntoView();
       }
     },
     [dispatch, emojiLibrary]
@@ -648,7 +684,7 @@ var useEmojiPicker = ({
         observeCategories({
           ancestorRef: refs.current.contentRoot,
           emojiLibrary,
-          setFocusedAndVisibleSections
+          setFocusedAndVisibleSections,
         });
       }, 0);
     }
@@ -656,20 +692,23 @@ var useEmojiPicker = ({
     emojiLibrary,
     state.isOpen,
     state.isSearching,
-    setFocusedAndVisibleSections
+    setFocusedAndVisibleSections,
   ]);
-  return __spreadValues({
-    setIsOpen,
-    i18n,
-    setSearch,
-    clearSearch,
-    emoji: state.emoji,
-    onMouseOver,
-    onSelectEmoji,
-    emojiLibrary,
-    handleCategoryClick,
-    refs
-  }, state);
+  return __spreadValues(
+    {
+      setIsOpen,
+      i18n,
+      setSearch,
+      clearSearch,
+      emoji: state.emoji,
+      onMouseOver,
+      onSelectEmoji,
+      emojiLibrary,
+      handleCategoryClick,
+      refs,
+    },
+    state
+  );
 };
 
 // src/utils/IndexSearch/IndexSearch.ts
@@ -697,8 +736,7 @@ var AIndexSearch = class {
     this.result = [];
     for (const key of this.library.keys) {
       const score = key.indexOf(`${value}`);
-      if (score === -1)
-        continue;
+      if (score === -1) continue;
       const emojiId = this.library.getEmojiId(key);
       this.result.push(emojiId);
       this.scores[emojiId] || (this.scores[emojiId] = 0);
@@ -727,8 +765,7 @@ var AIndexSearch = class {
     for (const key of this.result) {
       const emoji = (_a = this.library) == null ? void 0 : _a.getEmoji(key);
       emojis.push(this.transform(emoji));
-      if (emojis.length >= this.maxResult)
-        break;
+      if (emojis.length >= this.maxResult) break;
     }
     return emojis;
   }
@@ -745,7 +782,9 @@ var EmojiFloatingIndexSearch = class _EmojiFloatingIndexSearch extends AIndexSea
   }
   static getInstance(library) {
     if (!_EmojiFloatingIndexSearch.instance) {
-      _EmojiFloatingIndexSearch.instance = new _EmojiFloatingIndexSearch(library);
+      _EmojiFloatingIndexSearch.instance = new _EmojiFloatingIndexSearch(
+        library
+      );
     }
     return _EmojiFloatingIndexSearch.instance;
   }
@@ -777,17 +816,15 @@ var EmojiInlineIndexSearch = class _EmojiInlineIndexSearch extends AIndexSearch
         id,
         emoji: skins[0].native,
         name,
-        text: name
-      }
+        text: name,
+      },
     };
   }
 };
 
 // src/withEmoji.ts
 import { comboboxActions as comboboxActions2 } from "@udecode/plate-combobox";
-import {
-  isCollapsed as isCollapsed2
-} from "@udecode/plate-common";
+import { isCollapsed as isCollapsed2 } from "@udecode/plate-common";
 
 // src/handlers/getEmojiOnSelectItem.ts
 import { comboboxActions } from "@udecode/plate-combobox";
@@ -796,81 +833,93 @@ import {
   getPlugin as getPlugin2,
   insertText as insertText2,
   withoutMergingHistory,
-  withoutNormalizing as withoutNormalizing2
+  withoutNormalizing as withoutNormalizing2,
 } from "@udecode/plate-common";
-var getEmojiOnSelectItem = ({
-  key = KEY_EMOJI
-} = {}) => (editor, item) => {
-  const {
-    options: { createEmoji, emojiTriggeringController }
-  } = getPlugin2(editor, key);
-  withoutNormalizing2(editor, () => {
-    withoutMergingHistory(
-      editor,
-      () => deleteText(editor, {
-        distance: emojiTriggeringController.setIsTriggering(false).getTextSize(),
-        reverse: true
-      })
-    );
-    const value = createEmoji(item);
-    insertText2(editor, value);
-  });
-  return comboboxActions.reset();
-};
+var getEmojiOnSelectItem =
+  ({ key = KEY_EMOJI } = {}) =>
+  (editor, item) => {
+    const {
+      options: { createEmoji, emojiTriggeringController },
+    } = getPlugin2(editor, key);
+    withoutNormalizing2(editor, () => {
+      withoutMergingHistory(editor, () =>
+        deleteText(editor, {
+          distance: emojiTriggeringController
+            .setIsTriggering(false)
+            .getTextSize(),
+          reverse: true,
+        })
+      );
+      const value = createEmoji(item);
+      insertText2(editor, value);
+    });
+    return comboboxActions.reset();
+  };
 
 // src/handlers/getFindTriggeringInput.ts
 import {
   getEditorString,
   getPointBefore,
   getRange,
-  isCollapsed
+  isCollapsed,
 } from "@udecode/plate-common";
 var isSpaceBreak = (char) => !!char && /\s/.test(char);
-var getPreviousChar = (editor, point) => point ? getEditorString(
-  editor,
-  getRange(editor, point, getPointBefore(editor, point))
-) : void 0;
-var getPreviousPoint = (editor, point) => point ? getPointBefore(editor, point) : void 0;
+var getPreviousChar = (editor, point) =>
+  point
+    ? getEditorString(
+        editor,
+        getRange(editor, point, getPointBefore(editor, point))
+      )
+    : void 0;
+var getPreviousPoint = (editor, point) =>
+  point ? getPointBefore(editor, point) : void 0;
 var isBeginningOfTheLine = (editor, point) => {
   const previousPoint = getPreviousPoint(editor, point);
-  return (point == null ? void 0 : point.path[0]) !== (previousPoint == null ? void 0 : previousPoint.path[0]);
+  return (
+    (point == null ? void 0 : point.path[0]) !==
+    (previousPoint == null ? void 0 : previousPoint.path[0])
+  );
 };
-var getFindTriggeringInput = (editor, emojiTriggeringController) => ({ char = "", action = "insert" } = {}) => {
-  const { selection } = editor;
-  if (!selection || !isCollapsed(selection) || isSpaceBreak(char)) {
-    emojiTriggeringController.setIsTriggering(false);
-    return;
-  }
-  const startPoint = selection.anchor;
-  let currentPoint = startPoint;
-  let previousPoint;
-  let foundText = char;
-  let previousChar;
-  do {
-    previousChar = getPreviousChar(editor, currentPoint);
-    foundText = previousChar + foundText;
-    previousPoint = getPreviousPoint(editor, currentPoint);
-    if (isBeginningOfTheLine(editor, currentPoint)) {
-      break;
+var getFindTriggeringInput =
+  (editor, emojiTriggeringController) =>
+  ({ char = "", action = "insert" } = {}) => {
+    const { selection } = editor;
+    if (!selection || !isCollapsed(selection) || isSpaceBreak(char)) {
+      emojiTriggeringController.setIsTriggering(false);
+      return;
     }
-    currentPoint = previousPoint;
-  } while (!isSpaceBreak(previousChar));
-  foundText = foundText.trim();
-  if (action === "delete")
-    foundText = foundText.slice(0, -1);
-  emojiTriggeringController.setText(foundText);
-};
+    const startPoint = selection.anchor;
+    let currentPoint = startPoint;
+    let previousPoint;
+    let foundText = char;
+    let previousChar;
+    do {
+      previousChar = getPreviousChar(editor, currentPoint);
+      foundText = previousChar + foundText;
+      previousPoint = getPreviousPoint(editor, currentPoint);
+      if (isBeginningOfTheLine(editor, currentPoint)) {
+        break;
+      }
+      currentPoint = previousPoint;
+    } while (!isSpaceBreak(previousChar));
+    foundText = foundText.trim();
+    if (action === "delete") foundText = foundText.slice(0, -1);
+    emojiTriggeringController.setText(foundText);
+  };
 
 // src/withEmoji.ts
-var withEmoji = (editor, {
-  options: { id, emojiTriggeringController }
-}) => {
+var withEmoji = (editor, { options: { id, emojiTriggeringController } }) => {
   const emojiInlineIndexSearch = EmojiInlineIndexSearch.getInstance();
   const findTheTriggeringInput = getFindTriggeringInput(
     editor,
     emojiTriggeringController
   );
-  const { apply, insertText: insertText3, deleteBackward, deleteForward } = editor;
+  const {
+    apply,
+    insertText: insertText3,
+    deleteBackward,
+    deleteForward,
+  } = editor;
   editor.insertText = (char) => {
     const { selection } = editor;
     if (!isCollapsed2(selection)) {
@@ -889,7 +938,11 @@ var withEmoji = (editor, {
   };
   editor.apply = (operation) => {
     apply(operation);
-    if (!(emojiTriggeringController == null ? void 0 : emojiTriggeringController.hasTriggeringMark)) {
+    if (
+      !(emojiTriggeringController == null
+        ? void 0
+        : emojiTriggeringController.hasTriggeringMark)
+    ) {
       return;
     }
     const searchText = emojiTriggeringController.getText();
@@ -900,19 +953,26 @@ var withEmoji = (editor, {
         break;
       }
       case "insert_text": {
-        if (emojiTriggeringController.hasEnclosingTriggeringMark() && emojiInlineIndexSearch.search(searchText).hasFound(true)) {
+        if (
+          emojiTriggeringController.hasEnclosingTriggeringMark() &&
+          emojiInlineIndexSearch.search(searchText).hasFound(true)
+        ) {
           const item = emojiInlineIndexSearch.getEmoji();
           item && getEmojiOnSelectItem()(editor, item);
           break;
         }
-        if (!emojiTriggeringController.hasEnclosingTriggeringMark() && emojiTriggeringController.isTriggering && emojiInlineIndexSearch.search(searchText).hasFound()) {
+        if (
+          !emojiTriggeringController.hasEnclosingTriggeringMark() &&
+          emojiTriggeringController.isTriggering &&
+          emojiInlineIndexSearch.search(searchText).hasFound()
+        ) {
           comboboxActions2.items(
             emojiInlineIndexSearch.search(searchText).get()
           );
           comboboxActions2.open({
             activeId: id,
             text: "",
-            targetRange: editor.selection
+            targetRange: editor.selection,
           });
           break;
         }
@@ -921,14 +981,17 @@ var withEmoji = (editor, {
         break;
       }
       case "remove_text": {
-        if (emojiTriggeringController.isTriggering && emojiInlineIndexSearch.search(searchText).hasFound()) {
+        if (
+          emojiTriggeringController.isTriggering &&
+          emojiInlineIndexSearch.search(searchText).hasFound()
+        ) {
           comboboxActions2.items(
             emojiInlineIndexSearch.search(searchText).get()
           );
           comboboxActions2.open({
             activeId: id,
             text: "",
-            targetRange: editor.selection
+            targetRange: editor.selection,
           });
           break;
         }
@@ -948,27 +1011,33 @@ var createEmojiPlugin = createPluginFactory({
   options: {
     trigger: EMOJI_TRIGGER,
     createEmoji: (item) => item.data.emoji,
-    emojiTriggeringController: new EmojiTriggeringController()
+    emojiTriggeringController: new EmojiTriggeringController(),
   },
-  then: (_, { key, options: { trigger, createEmoji, emojiTriggeringController } }) => ({
+  then: (
+    _,
+    { key, options: { trigger, createEmoji, emojiTriggeringController } }
+  ) => ({
     options: {
       id: key,
       trigger,
       createEmoji,
-      emojiTriggeringController
-    }
-  })
+      emojiTriggeringController,
+    },
+  }),
 });
 
 // src/hooks/useEmojiCombobox.ts
-import { getPluginOptions, useEditorRef as useEditorRef2 } from "@udecode/plate-common";
+import {
+  getPluginOptions,
+  useEditorRef as useEditorRef2,
+} from "@udecode/plate-common";
 var useEmojiComboboxState = ({ pluginKey }) => {
   const editor = useEditorRef2();
   const { trigger } = getPluginOptions(editor, pluginKey);
   const onSelectItem = getEmojiOnSelectItem({ key: pluginKey });
   return {
     trigger,
-    onSelectItem
+    onSelectItem,
   };
 };
 
@@ -976,11 +1045,11 @@ var useEmojiComboboxState = ({ pluginKey }) => {
 import { useStableMemo } from "@udecode/plate-common";
 function useEmojiDropdownMenuState({
   settings = EmojiSettings,
-  closeOnSelect = true
+  closeOnSelect = true,
 } = {}) {
   const [emojiLibrary, indexSearch] = useStableMemo(() => {
     const frequentEmojiStorage = new FrequentEmojiStorage({
-      limit: settings.showFrequent.limit
+      limit: settings.showFrequent.limit,
     });
     const emojiLibrary2 = EmojiFloatingLibrary.getInstance(
       settings,
@@ -990,14 +1059,16 @@ function useEmojiDropdownMenuState({
     return [emojiLibrary2, indexSearch2];
   }, [settings]);
   const _a = useEmojiPicker({
-    closeOnSelect,
-    emojiLibrary,
-    indexSearch
-  }), { isOpen, setIsOpen } = _a, emojiPickerState = __objRest(_a, ["isOpen", "setIsOpen"]);
+      closeOnSelect,
+      emojiLibrary,
+      indexSearch,
+    }),
+    { isOpen, setIsOpen } = _a,
+    emojiPickerState = __objRest(_a, ["isOpen", "setIsOpen"]);
   return {
     isOpen,
     setIsOpen,
-    emojiPickerState
+    emojiPickerState,
   };
 }
 
@@ -1012,8 +1083,7 @@ var LocalStorage = class {
   }
   get() {
     let value = this.defaultValue;
-    if (typeof window === "undefined")
-      return value;
+    if (typeof window === "undefined") return value;
     const valueInLocalStorage = window.localStorage.getItem(this.key);
     if (valueInLocalStorage) {
       try {
@@ -1035,14 +1105,16 @@ var FrequentEmojiStorage = class {
     this.key = EmojiCategory.Frequent;
     var _a, _b, _c;
     this.limit = (_a = props.limit) != null ? _a : this.limit;
-    const key = `${(_b = props.prefix) != null ? _b : this.prefix}:${(_c = props.key) != null ? _c : this.key}`;
+    const key = `${(_b = props.prefix) != null ? _b : this.prefix}:${
+      (_c = props.key) != null ? _c : this.key
+    }`;
     this.localStorage = new LocalStorage(key, defaultValue);
   }
   update(emojiId) {
     const prevEmojis = this.localStorage.get();
     const count = prevEmojis[emojiId] ? prevEmojis[emojiId] + 1 : 1;
     const emojis = __spreadProps(__spreadValues({}, prevEmojis), {
-      [emojiId]: count
+      [emojiId]: count,
     });
     this.localStorage.set(emojis);
     return emojis;
@@ -1050,7 +1122,9 @@ var FrequentEmojiStorage = class {
   get() {
     const data = this.localStorage.get();
     return Object.fromEntries(
-      Object.keys(data).sort((a, b) => data[b] - data[a]).map((key) => [key, data[key]])
+      Object.keys(data)
+        .sort((a, b) => data[b] - data[a])
+        .map((key) => [key, data[key]])
     );
   }
   getList() {
@@ -1092,6 +1166,6 @@ export {
   useEmojiComboboxState,
   useEmojiDropdownMenuState,
   useEmojiPicker,
-  withEmoji
+  withEmoji,
 };
 //# sourceMappingURL=index.mjs.map
